To formalize the ideas behind our implementation, we define a
tiny source language $\cal L$:
polymorphic, higher-order, call-by-name $\lambda$-calculus with
algebraic datatypes, pattern matching, and recursion.  
Our actual implementation treats all of Haskell, by using GHC as a front 
end to translate Haskell into language $\cal L$.

\subsection{Syntax of $\cal L$} \label{s:syntax}

Figure~\ref{fig:syntax} presents the syntax of $\cal L$. 
A program $P$ consists of a set of recursive 
function definitions $f_1^{\ar_1}\ldots f_n^{\ar_n}$ each associated with an {\em arity} $\ar \geq 1$ 
which records the number of explicit abstractions of this function. Each of the function definitions
is of the form $\Lambda\as @.@ \lambda \ol{x{:}\tau} @.@ u$. A term $u$ is either a @case@ expression 
or a @case@-free expression $e$. A @case@-free expression consists of variables $x$, function variables 
$f[\taus]$ fully applied to their type arguments, applications $e_1\;e_2$, data constructor 
applications $K[\taus](\ol{e})$, as well as the special value @BAD@, which will be used to model 
failure as a throwable error term. In what follows we will be treating expressions $e$ as a subset 
of expressions $u$ to save some notation overhead. As a notation, we use $\oln{x}{n}$ for sequences
of elements of size $n$. When $n$ is ommitted $\ol{x}$ has a size which is implied by the context or 
is not interesting.

\begin{figure}
\[\begin{array}{l} 
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Programs, right-hand sides, and expressions}} \\
P   & ::= & @fix@\;(f_1^{\ar_1},...,f_k^{\ar_k})\;@=@ \\ 
    &     & \quad\quad (\Lambda\as_1 @.@ \lambda{\oln{x{:}\tau}{\ar_1}} @.@ u_1,...,
                                                \Lambda\as_k @.@ \lambda{\oln{x{:}\tau}{\ar_k}} @.@ u_k) \\
%% %% d   & ::= & f |-> \Lambda\ol{a} @.@ \lambda\ol{x{:}\tau} @.@ u \\ 
u   & ::= & e \mid @case@\;e\;@of@\;\ol{K\;\ol{y} -> e} \\ 
%%D   & ::= & \cdot \mid D,d \\
\end{array}
\\ 
\begin{array}{lrll}
e  & ::=  & x            & \text{Variables} \\ 
   & \mid & f[\ol{\tau}] & \text{Function variables} \\ 
   & \mid & K[\ol{\tau}](\ol{e}) & \text{Data constructors (fully applied)} \\
   & \mid & e\;e         & \text{Applications} \\
   & \mid & @BAD@        & \text{Runtime error} \\ 
\end{array}\\ \\ 
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Syntax of closed values}} \\
 v,w & ::= & K^\ar[\ol{\tau}](\oln{e}{\ar}) \;\mid\; f^\ar[\ol{\tau}]\;\oln{e}{m < \ar} \;\mid\; @BAD@ \\ \\ 
\end{array}
\\ 
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Contracts}} \\
 \Ct & ::=  & \{ x \mid e \}        & \text{Base contracts}  \\ 
     & \mid &  (x : \Ct_1) -> \Ct_2      & \text{Arrow contracts} \\ 
     & \mid & \Ct_1 \& \Ct_2             & \text{Conjunctions}   \\ 
     & \mid & \CF                        & \text{Crash-freedom}   \\
\end{array}
\\ \\
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Types}} \\
\tau,\sigma & ::=  & T\;\taus & \text{Datatypes} \\ 
            & \mid & a \mid \tau -> \tau 
\end{array}
\\ \\
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Type environments and signatures}} \\
\Gamma & ::=  & \cdot \mid \Gamma,x \\
\Delta & ::=  & \cdot \mid \Delta,a \mid \Delta,x{:}\tau \\
\Sigma & ::=  & \cdot \mid \Sigma,T{:}n \mid \Sigma,f{:}\forall\ol{a} @.@ \tau \mid \Sigma,K^{\ar}{:}\forall\ol{a} @.@ \oln{\tau}{\ar} -> @T@\;\as
\end{array}
\\ \\
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Auxiliary functions}} \\
%% constrs(\Sigma,T) & = & \{ K \mid (K{:}\forall \as @.@ \taus -> T\;\as) \in \Sigma \} \\
(\cdot)^{-}            & = & \cdot \\
(\Delta,a)^{-}         & = & \Delta^{-} \\
(\Delta,(x{:}\tau)^{-} & = & \Delta^{-},x
%% \tyar{D}{f} & = & n & \\ 
%%             & \multicolumn{3}{l}{\text{when}\; (f |-> \Lambda\oln{a}{n} @.@ \lambda\ol{x{:}\tau} @.@ u) \in D} \\
%% \tmar{D}{f} & = & n & \\ 
%%             & \multicolumn{3}{l}{\text{when}\; (f |-> \Lambda\ol{a} @.@ \lambda\oln{x{:}\tau}{n} @.@ u) \in D}
\end{array}
\end{array}\] 
\caption{Syntax of $\cal L$ and its contracts}\label{fig:syntax}
\end{figure}

Our language embodies several convenient syntactic constraints: (i)~$\lambda$
abstractions occur only at the top-level, (ii)~@case@-expressions can
only immediately follow a function definition, and (iii) constructors
are fully applied.  These constraints do not restrict expressiveness;
lambda-lifting, @case@-lifting, and eta-expansion respectively can
easily transform a program with nested constructs and
partially-applied constructors into our restricted form.  Indeed our
prototype relies on existing implementation of similar transformations
from the GHC-as-a-library API. However this simpler language is
instead extremely convenient for the translation of programs to
first-order logic.

Figure~\ref{fig:syntax} embodies one other inessential choice in order to 
facilitate the formalization and implementation: we assume that 
functions have arity at least one (disallowing CAF's).  \spj{Disallowing CAFs is quite significant.
We need to say more about why.}

$\cal L$ is an explicitly-typed language, and we assume the 
existence of a typing relation $\Sigma |- P$, which checks 
that a program conforms to the definitions in the signature $\Sigma$. A signature $\Sigma$ (Figure~\ref{fig:syntax})
records the declared data types, data constructors and types of functions in the program $P$. The 
well-formedness of expressions is checked with a typing relation $\Sigma;\Delta |- u : \tau$, where $\Delta$
is a typing environment, also in Figure~\ref{fig:syntax}.
We do not give the details of the typing relation since it is standard. An additional property that we require 
from the typing relation is that it {\em asserts the exhaustiveness of pattern matches}. In an {\em actual}
source language programmers may ommit pattern matches but here we will assume that all pattern matches 
are exhaustive. Originally-incomplete cases have been completed to return the crashing term @BAD@. For 
instance, the program:
\begin{code}
head :: [a] -> [a]
head (x::xs) = x
\end{code}
will be represented in our language as:
\[\begin{array}{l}
   \Lambda a @.@ \lambda (x{:}[a]) @.@ \\
   \quad @case@\;x\;@of@ \{ [] -> @BAD@ ; (x::xs) -> x \} 
\end{array}\]
Finally, our technical development and analysis in the following sections assume that programs have been 
checked for type errors. 

The syntax of closed values is also given in Figure~\ref{fig:syntax}. Since we do not 
have arbitrary $\lambda$-abstractions, values can only be partial function applications
$f^\ar[\ol{\tau}]\;\oln{e}{m < \ar}$, data constructor applications $K[\tau](\ol{e})$, 
and the error term @BAD@. 

\subsection{Operational semantics of $\cal L$}

\spj{Why do we give an operational as well as denotational semantics?}
The big-step operational semantics of our language is given in 
Figure~\ref{fig:opsem}, which contains no surprises. One interesting
detail of big-step semantics is that they do not distinguish between non-termination 
and ``getting stuck'', meaning that if $P \not|- e \Downarrow v$ then $e$ could either diverge or its 
evaluation could get stuck. We return to this convenient for our purposes form of operational 
semantics later. \spj{Where later? Also this sentence is hard to parse; indeed I'm not quite
sure what it means.}
\begin{figure}
\[\begin{array}{c} 
\ruleform{P |- u \Downarrow v} \\ 
\prooftree
\begin{array}{c} \ \\ 
\end{array}
-------------------------------------{EVal}
P |- v \Downarrow v
~~~~~
\begin{array}{c}
(f |-> \Lambda\ol{a} @.@ \lambda\oln{x{:}\tau}{m} @.@ u) \in P \\
P |- u[\ol{\tau}/\ol{a}][\ol{e}/\ol{x}] \Downarrow v
\end{array}
-------------------------------------{EFun}
P |- f[\ol{\tau}]\;\oln{e}{m} \Downarrow v
~~~~~
\begin{array}{c}  
P |- e_1 \Downarrow v_1 \\
P |- v_1\;e_2 \Downarrow w
\end{array}
------------------------------------------------{EApp}
P |- e_1\;e_2 \Downarrow w
~~~~~
\begin{array}{c}  
P |- e_1 \Downarrow @BAD@ 
\end{array}
------------------------------------------------{EBadApp}
P |- e_1\;e_2 \Downarrow @BAD@
~~~~~
%% \endprooftree \\ \\ 
%% \ruleform{P |- u \Downarrow v} \\ \\
%% \prooftree
%% P |- e \Downarrow v
%% -------------------------------------{EUTm}
%% P |- e \Downarrow v
%% ~~~~ 
\begin{array}{c}
P |- e \Downarrow K_i[\ol{\sigma}_i](\ol{e}_i) \quad
P |- e'_i[\ol{e}_i/\ol{y}_i] \Downarrow w
\end{array}
------------------------------------{ECase}
P |- @case@\;e\;@of@\;\ol{K\;\ol{y} -> e'} \Downarrow w
~~~~~
\begin{array}{c}
P |- e \Downarrow @BAD@ \\
\end{array}
------------------------------------{EBadCase}
P |- @case@\;e\;@of@\;\ol{K\;\ol{y} -> e'} \Downarrow @BAD@
%% \begin{array}{c}
%% (f |-> \Lambda\ol{a} @.@ \lambda\oln{x{:}\tau}{m} @.@ @case@\;e\;@of@\;\ol{K\;\ol{y} -> e'}) \in D \\
%% D |- e[\ol{\tau}/\ol{a}][\ol{e}/\ol{x}] \Downarrow @BAD@ \\
%% \end{array}
%% -------------------------------------{EBadCase}
%% D |- f[\ol{\tau}]\;\oln{e}{m} \Downarrow @BAD@
\endprooftree
\end{array}\]
\caption{Operational semantics of $\cal L$}\label{fig:opsem}
\end{figure}
%% We can state some standard properties of the typing and evaluation relation.
%% \begin{lemma}[Subject reduction]
%% Assume $\Sigma |- P$ and $\Sigma;\cdot |- e : \tau$
%% If $P |- e \Downarrow w$ then $P |- value(w)$ and $\Sigma;\cdot |- w : \tau$.
%% \end{lemma}
The operational semantics of Figure~\ref{fig:opsem} has the possibility of non-deterministism because
of the overlapping of several rules for applications. But that is not a problem, as we can prove that evaluation 
is deterministic using the following two lemmas.
\begin{lemma}[Value determinacy]
If $\Sigma;\cdot |- v : \tau$ and 
$\Sigma |- P$ and $P |- v \Downarrow w$ then $ v = w $.
\end{lemma}
\begin{lemma}[Determinacy of evaluation]
If $\Sigma;\cdot |- e : \tau$ and 
$\Sigma |- P$ and $\Sigma;\cdot |- e \Downarrow v_1$ and $\Sigma;\cdot |- e \Downarrow v_2$ then
$v_1 = v_2$.
\end{lemma}
Finally, big-step soundness asserts that an expression that evaluates results in a
well-typed value.
\begin{lemma}[Big-step soundness]
If $\Sigma;\cdot |- e : \tau$ and 
$\Sigma |- P$ and $\Sigma;\cdot |- e \Downarrow v$ then $\Sigma;\cdot |- v : \tau$.
\end{lemma}

\subsection{Contracts}

\begin{figure}
\[\begin{array}{lcl}
e \in \{ x\;\mid\;e_p\} & <=> &  e \not\Downarrow \text{ or } e_p[e/x] \not\Downarrow \text{ or} \\ 
                        &     &  e_p[e/x] \Downarrow True \\
e \in (x{:}\Ct_1) -> \Ct_2 & <=> & 
                        \forall e' \in \Ct_1.\; (e\;e') \in \Ct_2[e'/x] \\
e \in \Ct_1 \& \Ct_2 & <=> & e \in \Ct_1 \text{ and } e \in \Ct_2 \\
e \in \CF            & <=> & \forall {\cal C}. BAD \not\in {\cal C} \Rightarrow e \not\Downarrow BAD
\end{array} 
\]
\caption{Operational semantics of contracts} \label{f:contract-spec-op}
\end{figure}

We now turn our attention to contracts. The syntax of contracts
is given in Figure~\ref{fig:syntax} and includes base contracts
$\{ x \mid e \}$, arrow contructs $(x : \Ct_1) -> \Ct_2$, conjunctions
$\Ct_1 \& \Ct_2$ and crash-freedom $\CF$. Previous work~\cite{xu+:contracts} 
includes other constructs as well, but these constructs are enough to verify 
many programs and already demonstrate the interesting theoretical and practical problems.

We write $e \in C$ to mean ``the expression $e$ satisfies the contract $C$'', and similarly
for functions $f$.
Figure~\ref{f:contract-spec-op} says what it means to say $e \in C$,
based closely on earlier work \cite{xu}.  The specification is
simple, declarative, and intended to be comprehensible to programmers.
For example, an expression $e$ satisfies the function contract $\Ct_1 \& \Ct_2$ if and 
only if $(e e')$ satisfies $\Ct_2$ whenever $e'$ satisfies $Ct_1$.

Crucially, base contracts $\{x|e\}$ allow arbitrary $\cal L$
expressions (in our implementation, arbitrary Haskell expressions),
rather than being restricted to some well behaved meta-language.  This
is great for the programmer because the language and its library
functions is familiar, but it poses a challenge for verification
because these expressions in contracts may themselves diverge or
crash.

% -----------------------------------------------------------------
\section{Translating $\cal L$ to first-order logic} \label{ssect:denot-fol}

Our goal is to answer the question ``does expression $e$ satisfy
contract $C$.  Out plan is to translate both the expression and the
contract into first-order logic (FOL), and get a standard FOL prover
to do the heavy lifting.  In this section we describe our new
translation, and how to use it to verify contracts.

\subsection{The FOL language}

We begin with the syntax of the FOL language, which
is given in Figure~\ref{fig:fol-image}. Terms include function 
applications $f(\ol{t})$, constructor applications $K(\ol{t})$, variables. They 
also include, for each data constructor $K^\ar$ in the signature $\Sigma$ with 
arity $\ar$ a set of {\em selector functions} $\sel{K}{i}(t)$ for $i \in 1 \ldots \ar$.
Not all functions are fully applied, so to accommodate partial applications, we use 
the term $app(t,s)$. Functions that are not applied, but rather passed on as essentially 
function pointers will be represented as variables (or nullary functions) $f_{ptr}$. Finally 
we introduce two new syntactic constructs $\unr$ and $\bad$. As an abreviation we often use
$app(t,\ol{s})$ for the sequence of applications to each $s_i$, as 
Figure~\ref{fig:fol-image} shows.

\begin{figure}
\[\begin{array}{c} 
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Terms}} \\
  s,t & ::=  & x                          & \text{Variables} \\ 
      &      & f(\ol{t})                  & \text{Functions} \\
      &      & K(\ol{t})                  & \text{Constructor functions} \\ 
      & \mid & \sel{K}{i}(t)              & \text{Constructor selectors} \\ 
      & \mid & f_{ptr} \mid app(t,s)       & \text{Pointers and application} \\
      & \mid & \unr \mid \bad             & \text{Unreachable, bad} \\ \\
\multicolumn{3}{l}{\text{Formulae}} \\ 
 \phi & ::=  & \lcf{t}    & \text{Crash-freedom} \\
%%      & \mid & \lncf{t}   & \text{Can provably cause crash} \\
      & \mid & t_1 = t_2  & \text{Equality} \\ 
      & \mid & \phi \land \phi \mid \phi \lor \phi \mid \neg \phi \\
      & \mid & \forall x @.@ \phi \mid \exists x @.@ \phi \\ \\ 
\multicolumn{3}{l}{\text{Abbreviation}} \\ 
\multicolumn{4}{l}{app(t,\oln{s}{n}) = (\ldots(app(t,s_1),\ldots s_n)\ldots)}
\end{array}
\end{array}\]
\caption{Syntax of FOL}\label{fig:fol-image}
\end{figure}

To group interesting definitions together, Figure~\ref{fig:fol-image}
also includes the syntax of formulae that will appear in our translation.
It is just first-order logic with equality, plus a predicate $\lcf{t}$ for 
crash-freedom, whose semantics we discuss in Section~\ref{sect:contracts}.


\begin{figure}\small
\[\begin{array}{c} 
\ruleform{\etrans{\Sigma}{\Gamma}{e} = \formula{t} } \\ \\
\prooftree
  \begin{array}{c}
  (f{:}\forall\oln{a}{n} @.@ \tau) \in \Sigma
  \end{array}
  --------------------------------------{TFVar}
  \etrans{\Sigma}{\Gamma}{f[\oln{\tau}{n}]} = \formula{f_{ptr}}
  ~~~~ 
  x \in \Gamma 
  --------------------------------------{TVar}
  \etrans{\Sigma}{\Gamma}{x} = \formula{x}
  ~~~~~ 
  \begin{array}{c}
  (K{:}\forall\oln{a}{n} @.@ \ol{\tau} -> T\;\as) \in \Sigma \quad
  \ol{\etrans{\Sigma}{\Gamma}{e} = \formula{t}}
  \end{array}
  --------------------------------------{TCon}
  \etrans{\Sigma}{\Gamma}{K[\oln{\tau}{n}](\ol{e})} = \formula{K(\ol{t})}
  ~~~~~
  \phantom{\Gamma}
  --------------------------------------{TBad}
  \etrans{\Sigma}{\Gamma}{@BAD@} = \formula{\bad}
  ~~~~
  \begin{array}{c}
  \etrans{\Sigma}{\Gamma}{e_1} = \formula{t_1} \\
  \etrans{\Sigma}{\Gamma}{e_2} = \formula{t_2}
  \end{array}
  --------------------------------------{TApp}
  \etrans{\Sigma}{\Gamma}{e_1\;e_2} = \formula{app(t_1,t_2)}
\endprooftree \\ \\ 
\ruleform{\utrans{\Sigma}{\Gamma}{t \sim u} = \formula{\phi}} \\ \\ 
\prooftree
   \etrans{\Sigma}{\Gamma}{e} = \formula{t}
   ----------------------------------------{DExp}
   \utrans{\Sigma}{\Gamma}{s \sim e } = \formula{s = t} 
   ~~~~~
  \begin{array}{l}
  \etrans{\Sigma}{\Gamma}{e} = \formula{t} \\
%%  constrs(\Sigma,T) = \ol{K} \\
  \text{for each branch}\;(K\;\oln{y}{l} -> e') \text{ it is } \etrans{\Sigma}{\Gamma,\ol{y}}{e'} = \formula{ t_K }
%%  \begin{array}{l}
%% %%           (K{:}\forall \cs @.@ \oln{\sigma}{l} -> T\;\oln{c}{k}) \in \Sigma \text{ and }
%%            \etrans{\Sigma}{\Gamma,\ol{y}}{e'} = \formula{ t_K }
%%   \end{array}
  \end{array}
  ------------------------------------------{DCase}
  {  \setlength{\arraycolsep}{2pt} 
  \begin{array}{l}
  \utrans{\Sigma}{\Gamma}{s \sim @case@\;e\;@of@\;\ol{K\;\ol{y} -> e'}} = \\
  \;\;\formula{ \begin{array}{l} 
          (t = \bad => s = bad)\;\land \\ 
          (\forall \ol{y} @.@ t = K_1(\ol{y}) => s = t_{K_1}\;\land \ldots \land \\
          (t{\neq}\bad\;\land\;t{\neq}K_1(\oln{{\sel{K_1}{i}}(t)}{})\;\land\;\ldots => s{=}\unr) 
%% (t = \bad /\ s = \bad)\;\lor\;(s = \unr)\;\lor \\
%%                                 \quad      \bigvee(t = K(\oln{{\sel{K}{i}}(t)}{}) \land
%%                                            s = t_K[\oln{\sel{K}{i}(t)}{}/\ol{y}])
                   \end{array}
           }
  \end{array}}
\endprooftree \\ \\ 
\ruleform{ \Dtrans{\Sigma}{P} = \formula{\phi}} \\ \\ 
\prooftree
     \begin{array}{l}       
       \text{for each} (f |-> \Lambda\oln{a}{n} @.@ \lambda\oln{x{:}\tau}{m} @.@ u) \in P \\ 
          \quad \utrans{\Sigma}{\ol{x}}{f(\ol{x}) \sim u} = \formula{\phi}
     \end{array}
     --------------------{TDefs}
     \Dtrans{\Sigma}{P} = \bigwedge_{P} \formula{\forall \ol{x} @.@ \phi}
\endprooftree 

\end{array}\]
\caption{Translation to FOL terms}\label{fig:etrans}
\end{figure}

\subsection{Translation of expressions to FOL}

The translation of expressions $e$ which may contain term variables from $\Gamma$ to 
first-order logic terms is given in Figure~\ref{fig:etrans} with the function
$\etrans{}{\Gamma}{e}$. Variables map to variables, functions map to function pointers, 
applications map to applications of $app(\cdot,\cdot)$, constructors map to constructor
function applications and @BAD@ maps to $\bad$.


\subsection{Translation of programs and {\tt case} expressions}
A program $P$ is translated to a first order logic formula with the function 
$\dtrans{}{P}$. For each function definition of a function $f^\ar$ we generate
a quantified formula $\forall \xs @.@ \utrans{}{\ol{x}}{f(\ol{x}) \sim u}$ where $u$ is the 
right-hand side of the definition of $f$ in $P$. The function 
$\utrans{}{\Gamma}{t \sim u}$ generates the necessary formula to equate the left-hand-side
first-order term $t$ to a term corresponding to $u$. The context $\Gamma$ is present
for book-keeping purposes. As Figure~\ref{fig:etrans} shows there are two cases to 
consider. If $u$ is just a @case@-free expression $e$, in which case we generate
an equality formula (rule \rulename{DExp}. 

The most interesting rule is \rulename{DCase}. If the translation of the scrutinee
$t$ is equal to $\bad$ then the left-hand-side $s$ must be equal to $\bad$. If it is 
equal to some constructor application from the case expressions then the right 
hand-side is equal to the corresponding translation $t_K$ of some pattern branch. Finally
if the scrutinee is not $\bad$ nor some of the constructors in the branch we assert that
the left-hand-side $s$ must be equal to $\unr$. The rule precisely corresponds to our 
intuitions from the denotational semantics: in the denotational semantics, whenever
we attempt to scrutinize a constructor of a different type in a case expression, the 
resulting denotation is simply $\bot$. This reinforces our desire to treat type errors
as $\bot$ values. 

